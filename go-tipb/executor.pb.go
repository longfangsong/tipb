// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: executor.proto

package tipb

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ExecType int32

const (
	ExecType_TypeTableScan        ExecType = 0
	ExecType_TypeIndexScan        ExecType = 1
	ExecType_TypeSelection        ExecType = 2
	ExecType_TypeAggregation      ExecType = 3
	ExecType_TypeTopN             ExecType = 4
	ExecType_TypeLimit            ExecType = 5
	ExecType_TypeStreamAgg        ExecType = 6
	ExecType_TypeJoin             ExecType = 7
	ExecType_TypeKill             ExecType = 8
	ExecType_TypeExchangeSender   ExecType = 9
	ExecType_TypeExchangeReceiver ExecType = 10
	ExecType_TypeProjection       ExecType = 11
)

var ExecType_name = map[int32]string{
	0:  "TypeTableScan",
	1:  "TypeIndexScan",
	2:  "TypeSelection",
	3:  "TypeAggregation",
	4:  "TypeTopN",
	5:  "TypeLimit",
	6:  "TypeStreamAgg",
	7:  "TypeJoin",
	8:  "TypeKill",
	9:  "TypeExchangeSender",
	10: "TypeExchangeReceiver",
	11: "TypeProjection",
}

var ExecType_value = map[string]int32{
	"TypeTableScan":        0,
	"TypeIndexScan":        1,
	"TypeSelection":        2,
	"TypeAggregation":      3,
	"TypeTopN":             4,
	"TypeLimit":            5,
	"TypeStreamAgg":        6,
	"TypeJoin":             7,
	"TypeKill":             8,
	"TypeExchangeSender":   9,
	"TypeExchangeReceiver": 10,
	"TypeProjection":       11,
}

func (x ExecType) Enum() *ExecType {
	p := new(ExecType)
	*p = x
	return p
}

func (x ExecType) String() string {
	return proto.EnumName(ExecType_name, int32(x))
}

func (x *ExecType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ExecType_value, data, "ExecType")
	if err != nil {
		return err
	}
	*x = ExecType(value)
	return nil
}

func (ExecType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{0}
}

type ExchangeType int32

const (
	ExchangeType_PassThrough ExchangeType = 0
	ExchangeType_Broadcast   ExchangeType = 1
	ExchangeType_Hash        ExchangeType = 2
)

var ExchangeType_name = map[int32]string{
	0: "PassThrough",
	1: "Broadcast",
	2: "Hash",
}

var ExchangeType_value = map[string]int32{
	"PassThrough": 0,
	"Broadcast":   1,
	"Hash":        2,
}

func (x ExchangeType) Enum() *ExchangeType {
	p := new(ExchangeType)
	*p = x
	return p
}

func (x ExchangeType) String() string {
	return proto.EnumName(ExchangeType_name, int32(x))
}

func (x *ExchangeType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ExchangeType_value, data, "ExchangeType")
	if err != nil {
		return err
	}
	*x = ExchangeType(value)
	return nil
}

func (ExchangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{1}
}

type EngineType int32

const (
	EngineType_Local   EngineType = 0
	EngineType_TiKV    EngineType = 1
	EngineType_TiFlash EngineType = 2
)

var EngineType_name = map[int32]string{
	0: "Local",
	1: "TiKV",
	2: "TiFlash",
}

var EngineType_value = map[string]int32{
	"Local":   0,
	"TiKV":    1,
	"TiFlash": 2,
}

func (x EngineType) Enum() *EngineType {
	p := new(EngineType)
	*p = x
	return p
}

func (x EngineType) String() string {
	return proto.EnumName(EngineType_name, int32(x))
}

func (x *EngineType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EngineType_value, data, "EngineType")
	if err != nil {
		return err
	}
	*x = EngineType(value)
	return nil
}

func (EngineType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{2}
}

type JoinType int32

const (
	JoinType_TypeInnerJoin             JoinType = 0
	JoinType_TypeLeftOuterJoin         JoinType = 1
	JoinType_TypeRightOuterJoin        JoinType = 2
	JoinType_TypeSemiJoin              JoinType = 3
	JoinType_TypeAntiSemiJoin          JoinType = 4
	JoinType_TypeLeftOuterSemiJoin     JoinType = 5
	JoinType_TypeAntiLeftOuterSemiJoin JoinType = 6
)

var JoinType_name = map[int32]string{
	0: "TypeInnerJoin",
	1: "TypeLeftOuterJoin",
	2: "TypeRightOuterJoin",
	3: "TypeSemiJoin",
	4: "TypeAntiSemiJoin",
	5: "TypeLeftOuterSemiJoin",
	6: "TypeAntiLeftOuterSemiJoin",
}

var JoinType_value = map[string]int32{
	"TypeInnerJoin":             0,
	"TypeLeftOuterJoin":         1,
	"TypeRightOuterJoin":        2,
	"TypeSemiJoin":              3,
	"TypeAntiSemiJoin":          4,
	"TypeLeftOuterSemiJoin":     5,
	"TypeAntiLeftOuterSemiJoin": 6,
}

func (x JoinType) Enum() *JoinType {
	p := new(JoinType)
	*p = x
	return p
}

func (x JoinType) String() string {
	return proto.EnumName(JoinType_name, int32(x))
}

func (x *JoinType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(JoinType_value, data, "JoinType")
	if err != nil {
		return err
	}
	*x = JoinType(value)
	return nil
}

func (JoinType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{3}
}

type JoinExecType int32

const (
	JoinExecType_TypeHashJoin JoinExecType = 0
)

var JoinExecType_name = map[int32]string{
	0: "TypeHashJoin",
}

var JoinExecType_value = map[string]int32{
	"TypeHashJoin": 0,
}

func (x JoinExecType) Enum() *JoinExecType {
	p := new(JoinExecType)
	*p = x
	return p
}

func (x JoinExecType) String() string {
	return proto.EnumName(JoinExecType_name, int32(x))
}

func (x *JoinExecType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(JoinExecType_value, data, "JoinExecType")
	if err != nil {
		return err
	}
	*x = JoinExecType(value)
	return nil
}

func (JoinExecType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{4}
}

// It represents a Executor.
type Executor struct {
	Tp                   ExecType          `protobuf:"varint,1,opt,name=tp,enum=tipb.ExecType" json:"tp"`
	TblScan              *TableScan        `protobuf:"bytes,2,opt,name=tbl_scan,json=tblScan" json:"tbl_scan,omitempty"`
	IdxScan              *IndexScan        `protobuf:"bytes,3,opt,name=idx_scan,json=idxScan" json:"idx_scan,omitempty"`
	Selection            *Selection        `protobuf:"bytes,4,opt,name=selection" json:"selection,omitempty"`
	Aggregation          *Aggregation      `protobuf:"bytes,5,opt,name=aggregation" json:"aggregation,omitempty"`
	TopN                 *TopN             `protobuf:"bytes,6,opt,name=topN" json:"topN,omitempty"`
	Limit                *Limit            `protobuf:"bytes,7,opt,name=limit" json:"limit,omitempty"`
	ExchangeReceiver     *ExchangeReceiver `protobuf:"bytes,8,opt,name=exchange_receiver,json=exchangeReceiver" json:"exchange_receiver,omitempty"`
	Join                 *Join             `protobuf:"bytes,9,opt,name=join" json:"join,omitempty"`
	ExecutorId           *string           `protobuf:"bytes,10,opt,name=executor_id,json=executorId" json:"executor_id,omitempty"`
	Kill                 *Kill             `protobuf:"bytes,11,opt,name=kill" json:"kill,omitempty"`
	ExchangeSender       *ExchangeSender   `protobuf:"bytes,12,opt,name=exchange_sender,json=exchangeSender" json:"exchange_sender,omitempty"`
	Projection           *Projection       `protobuf:"bytes,13,opt,name=Projection" json:"Projection,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Executor) Reset()         { *m = Executor{} }
func (m *Executor) String() string { return proto.CompactTextString(m) }
func (*Executor) ProtoMessage()    {}
func (*Executor) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{0}
}
func (m *Executor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Executor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Executor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Executor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Executor.Merge(m, src)
}
func (m *Executor) XXX_Size() int {
	return m.Size()
}
func (m *Executor) XXX_DiscardUnknown() {
	xxx_messageInfo_Executor.DiscardUnknown(m)
}

var xxx_messageInfo_Executor proto.InternalMessageInfo

func (m *Executor) GetTp() ExecType {
	if m != nil {
		return m.Tp
	}
	return ExecType_TypeTableScan
}

func (m *Executor) GetTblScan() *TableScan {
	if m != nil {
		return m.TblScan
	}
	return nil
}

func (m *Executor) GetIdxScan() *IndexScan {
	if m != nil {
		return m.IdxScan
	}
	return nil
}

func (m *Executor) GetSelection() *Selection {
	if m != nil {
		return m.Selection
	}
	return nil
}

func (m *Executor) GetAggregation() *Aggregation {
	if m != nil {
		return m.Aggregation
	}
	return nil
}

func (m *Executor) GetTopN() *TopN {
	if m != nil {
		return m.TopN
	}
	return nil
}

func (m *Executor) GetLimit() *Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Executor) GetExchangeReceiver() *ExchangeReceiver {
	if m != nil {
		return m.ExchangeReceiver
	}
	return nil
}

func (m *Executor) GetJoin() *Join {
	if m != nil {
		return m.Join
	}
	return nil
}

func (m *Executor) GetExecutorId() string {
	if m != nil && m.ExecutorId != nil {
		return *m.ExecutorId
	}
	return ""
}

func (m *Executor) GetKill() *Kill {
	if m != nil {
		return m.Kill
	}
	return nil
}

func (m *Executor) GetExchangeSender() *ExchangeSender {
	if m != nil {
		return m.ExchangeSender
	}
	return nil
}

func (m *Executor) GetProjection() *Projection {
	if m != nil {
		return m.Projection
	}
	return nil
}

// ExchangeSender will build connection with ExchangeReceiver.
type ExchangeSender struct {
	Tp                   ExchangeType `protobuf:"varint,1,opt,name=tp,enum=tipb.ExchangeType" json:"tp"`
	EncodedTaskMeta      [][]byte     `protobuf:"bytes,2,rep,name=encoded_task_meta,json=encodedTaskMeta" json:"encoded_task_meta,omitempty"`
	PartitionKeys        []*Expr      `protobuf:"bytes,3,rep,name=partition_keys,json=partitionKeys" json:"partition_keys,omitempty"`
	Child                *Executor    `protobuf:"bytes,4,opt,name=child" json:"child,omitempty"`
	Types                []*FieldType `protobuf:"bytes,5,rep,name=types" json:"types,omitempty"`
	AllFieldTypes        []*FieldType `protobuf:"bytes,6,rep,name=all_field_types,json=allFieldTypes" json:"all_field_types,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ExchangeSender) Reset()         { *m = ExchangeSender{} }
func (m *ExchangeSender) String() string { return proto.CompactTextString(m) }
func (*ExchangeSender) ProtoMessage()    {}
func (*ExchangeSender) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{1}
}
func (m *ExchangeSender) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeSender) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeSender.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeSender) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeSender.Merge(m, src)
}
func (m *ExchangeSender) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeSender) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeSender.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeSender proto.InternalMessageInfo

func (m *ExchangeSender) GetTp() ExchangeType {
	if m != nil {
		return m.Tp
	}
	return ExchangeType_PassThrough
}

func (m *ExchangeSender) GetEncodedTaskMeta() [][]byte {
	if m != nil {
		return m.EncodedTaskMeta
	}
	return nil
}

func (m *ExchangeSender) GetPartitionKeys() []*Expr {
	if m != nil {
		return m.PartitionKeys
	}
	return nil
}

func (m *ExchangeSender) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *ExchangeSender) GetTypes() []*FieldType {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *ExchangeSender) GetAllFieldTypes() []*FieldType {
	if m != nil {
		return m.AllFieldTypes
	}
	return nil
}

// ExchangeReceiver accept connection and receiver data from ExchangeSender.
type ExchangeReceiver struct {
	EncodedTaskMeta      [][]byte      `protobuf:"bytes,1,rep,name=encoded_task_meta,json=encodedTaskMeta" json:"encoded_task_meta,omitempty"`
	FieldTypes           []*FieldType  `protobuf:"bytes,2,rep,name=field_types,json=fieldTypes" json:"field_types,omitempty"`
	Tp                   *ExchangeType `protobuf:"varint,3,opt,name=tp,enum=tipb.ExchangeType" json:"tp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ExchangeReceiver) Reset()         { *m = ExchangeReceiver{} }
func (m *ExchangeReceiver) String() string { return proto.CompactTextString(m) }
func (*ExchangeReceiver) ProtoMessage()    {}
func (*ExchangeReceiver) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{2}
}
func (m *ExchangeReceiver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeReceiver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeReceiver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeReceiver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeReceiver.Merge(m, src)
}
func (m *ExchangeReceiver) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeReceiver) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeReceiver.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeReceiver proto.InternalMessageInfo

func (m *ExchangeReceiver) GetEncodedTaskMeta() [][]byte {
	if m != nil {
		return m.EncodedTaskMeta
	}
	return nil
}

func (m *ExchangeReceiver) GetFieldTypes() []*FieldType {
	if m != nil {
		return m.FieldTypes
	}
	return nil
}

func (m *ExchangeReceiver) GetTp() ExchangeType {
	if m != nil && m.Tp != nil {
		return *m.Tp
	}
	return ExchangeType_PassThrough
}

type TableScan struct {
	TableId                int64         `protobuf:"varint,1,opt,name=table_id,json=tableId" json:"table_id"`
	Columns                []*ColumnInfo `protobuf:"bytes,2,rep,name=columns" json:"columns,omitempty"`
	Desc                   bool          `protobuf:"varint,3,opt,name=desc" json:"desc"`
	PrimaryColumnIds       []int64       `protobuf:"varint,4,rep,name=primary_column_ids,json=primaryColumnIds" json:"primary_column_ids,omitempty"`
	NextReadEngine         EngineType    `protobuf:"varint,5,opt,name=next_read_engine,json=nextReadEngine,enum=tipb.EngineType" json:"next_read_engine"`
	Ranges                 []KeyRange    `protobuf:"bytes,6,rep,name=ranges" json:"ranges"`
	PrimaryPrefixColumnIds []int64       `protobuf:"varint,7,rep,name=primary_prefix_column_ids,json=primaryPrefixColumnIds" json:"primary_prefix_column_ids,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}      `json:"-"`
	XXX_unrecognized       []byte        `json:"-"`
	XXX_sizecache          int32         `json:"-"`
}

func (m *TableScan) Reset()         { *m = TableScan{} }
func (m *TableScan) String() string { return proto.CompactTextString(m) }
func (*TableScan) ProtoMessage()    {}
func (*TableScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{3}
}
func (m *TableScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableScan.Merge(m, src)
}
func (m *TableScan) XXX_Size() int {
	return m.Size()
}
func (m *TableScan) XXX_DiscardUnknown() {
	xxx_messageInfo_TableScan.DiscardUnknown(m)
}

var xxx_messageInfo_TableScan proto.InternalMessageInfo

func (m *TableScan) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *TableScan) GetColumns() []*ColumnInfo {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *TableScan) GetDesc() bool {
	if m != nil {
		return m.Desc
	}
	return false
}

func (m *TableScan) GetPrimaryColumnIds() []int64 {
	if m != nil {
		return m.PrimaryColumnIds
	}
	return nil
}

func (m *TableScan) GetNextReadEngine() EngineType {
	if m != nil {
		return m.NextReadEngine
	}
	return EngineType_Local
}

func (m *TableScan) GetRanges() []KeyRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *TableScan) GetPrimaryPrefixColumnIds() []int64 {
	if m != nil {
		return m.PrimaryPrefixColumnIds
	}
	return nil
}

type Join struct {
	JoinType      JoinType     `protobuf:"varint,1,opt,name=join_type,json=joinType,enum=tipb.JoinType" json:"join_type"`
	JoinExecType  JoinExecType `protobuf:"varint,2,opt,name=join_exec_type,json=joinExecType,enum=tipb.JoinExecType" json:"join_exec_type"`
	Children      []*Executor  `protobuf:"bytes,3,rep,name=children" json:"children,omitempty"`
	InnerIdx      int64        `protobuf:"varint,4,opt,name=inner_idx,json=innerIdx" json:"inner_idx"`
	LeftJoinKeys  []*Expr      `protobuf:"bytes,5,rep,name=left_join_keys,json=leftJoinKeys" json:"left_join_keys,omitempty"`
	RightJoinKeys []*Expr      `protobuf:"bytes,6,rep,name=right_join_keys,json=rightJoinKeys" json:"right_join_keys,omitempty"`
	// used by TiFlash join when new collation is enabled.
	ProbeTypes              []*FieldType `protobuf:"bytes,7,rep,name=probe_types,json=probeTypes" json:"probe_types,omitempty"`
	BuildTypes              []*FieldType `protobuf:"bytes,8,rep,name=build_types,json=buildTypes" json:"build_types,omitempty"`
	LeftConditions          []*Expr      `protobuf:"bytes,9,rep,name=left_conditions,json=leftConditions" json:"left_conditions,omitempty"`
	RightConditions         []*Expr      `protobuf:"bytes,10,rep,name=right_conditions,json=rightConditions" json:"right_conditions,omitempty"`
	OtherConditions         []*Expr      `protobuf:"bytes,11,rep,name=other_conditions,json=otherConditions" json:"other_conditions,omitempty"`
	OtherEqConditionsFromIn []*Expr      `protobuf:"bytes,12,rep,name=other_eq_conditions_from_in,json=otherEqConditionsFromIn" json:"other_eq_conditions_from_in,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}     `json:"-"`
	XXX_unrecognized        []byte       `json:"-"`
	XXX_sizecache           int32        `json:"-"`
}

func (m *Join) Reset()         { *m = Join{} }
func (m *Join) String() string { return proto.CompactTextString(m) }
func (*Join) ProtoMessage()    {}
func (*Join) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{4}
}
func (m *Join) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Join) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Join.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Join) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Join.Merge(m, src)
}
func (m *Join) XXX_Size() int {
	return m.Size()
}
func (m *Join) XXX_DiscardUnknown() {
	xxx_messageInfo_Join.DiscardUnknown(m)
}

var xxx_messageInfo_Join proto.InternalMessageInfo

func (m *Join) GetJoinType() JoinType {
	if m != nil {
		return m.JoinType
	}
	return JoinType_TypeInnerJoin
}

func (m *Join) GetJoinExecType() JoinExecType {
	if m != nil {
		return m.JoinExecType
	}
	return JoinExecType_TypeHashJoin
}

func (m *Join) GetChildren() []*Executor {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Join) GetInnerIdx() int64 {
	if m != nil {
		return m.InnerIdx
	}
	return 0
}

func (m *Join) GetLeftJoinKeys() []*Expr {
	if m != nil {
		return m.LeftJoinKeys
	}
	return nil
}

func (m *Join) GetRightJoinKeys() []*Expr {
	if m != nil {
		return m.RightJoinKeys
	}
	return nil
}

func (m *Join) GetProbeTypes() []*FieldType {
	if m != nil {
		return m.ProbeTypes
	}
	return nil
}

func (m *Join) GetBuildTypes() []*FieldType {
	if m != nil {
		return m.BuildTypes
	}
	return nil
}

func (m *Join) GetLeftConditions() []*Expr {
	if m != nil {
		return m.LeftConditions
	}
	return nil
}

func (m *Join) GetRightConditions() []*Expr {
	if m != nil {
		return m.RightConditions
	}
	return nil
}

func (m *Join) GetOtherConditions() []*Expr {
	if m != nil {
		return m.OtherConditions
	}
	return nil
}

func (m *Join) GetOtherEqConditionsFromIn() []*Expr {
	if m != nil {
		return m.OtherEqConditionsFromIn
	}
	return nil
}

type IndexScan struct {
	TableId              int64         `protobuf:"varint,1,opt,name=table_id,json=tableId" json:"table_id"`
	IndexId              int64         `protobuf:"varint,2,opt,name=index_id,json=indexId" json:"index_id"`
	Columns              []*ColumnInfo `protobuf:"bytes,3,rep,name=columns" json:"columns,omitempty"`
	Desc                 bool          `protobuf:"varint,4,opt,name=desc" json:"desc"`
	Unique               *bool         `protobuf:"varint,5,opt,name=unique" json:"unique,omitempty"`
	PrimaryColumnIds     []int64       `protobuf:"varint,6,rep,name=primary_column_ids,json=primaryColumnIds" json:"primary_column_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *IndexScan) Reset()         { *m = IndexScan{} }
func (m *IndexScan) String() string { return proto.CompactTextString(m) }
func (*IndexScan) ProtoMessage()    {}
func (*IndexScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{5}
}
func (m *IndexScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexScan.Merge(m, src)
}
func (m *IndexScan) XXX_Size() int {
	return m.Size()
}
func (m *IndexScan) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexScan.DiscardUnknown(m)
}

var xxx_messageInfo_IndexScan proto.InternalMessageInfo

func (m *IndexScan) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *IndexScan) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *IndexScan) GetColumns() []*ColumnInfo {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *IndexScan) GetDesc() bool {
	if m != nil {
		return m.Desc
	}
	return false
}

func (m *IndexScan) GetUnique() bool {
	if m != nil && m.Unique != nil {
		return *m.Unique
	}
	return false
}

func (m *IndexScan) GetPrimaryColumnIds() []int64 {
	if m != nil {
		return m.PrimaryColumnIds
	}
	return nil
}

type Selection struct {
	// Where conditions.
	Conditions           []*Expr    `protobuf:"bytes,1,rep,name=conditions" json:"conditions,omitempty"`
	RpnConditions        []*RpnExpr `protobuf:"bytes,2,rep,name=rpn_conditions,json=rpnConditions" json:"rpn_conditions,omitempty"`
	Child                *Executor  `protobuf:"bytes,3,opt,name=child" json:"child,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Selection) Reset()         { *m = Selection{} }
func (m *Selection) String() string { return proto.CompactTextString(m) }
func (*Selection) ProtoMessage()    {}
func (*Selection) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{6}
}
func (m *Selection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Selection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Selection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Selection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Selection.Merge(m, src)
}
func (m *Selection) XXX_Size() int {
	return m.Size()
}
func (m *Selection) XXX_DiscardUnknown() {
	xxx_messageInfo_Selection.DiscardUnknown(m)
}

var xxx_messageInfo_Selection proto.InternalMessageInfo

func (m *Selection) GetConditions() []*Expr {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *Selection) GetRpnConditions() []*RpnExpr {
	if m != nil {
		return m.RpnConditions
	}
	return nil
}

func (m *Selection) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

type Projection struct {
	// Projection expressions.
	Exprs                []*Expr    `protobuf:"bytes,1,rep,name=exprs" json:"exprs,omitempty"`
	RpnExprs             []*RpnExpr `protobuf:"bytes,2,rep,name=rpn_exprs,json=rpnExprs" json:"rpn_exprs,omitempty"`
	Child                *Executor  `protobuf:"bytes,3,opt,name=child" json:"child,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Projection) Reset()         { *m = Projection{} }
func (m *Projection) String() string { return proto.CompactTextString(m) }
func (*Projection) ProtoMessage()    {}
func (*Projection) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{7}
}
func (m *Projection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Projection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Projection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Projection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Projection.Merge(m, src)
}
func (m *Projection) XXX_Size() int {
	return m.Size()
}
func (m *Projection) XXX_DiscardUnknown() {
	xxx_messageInfo_Projection.DiscardUnknown(m)
}

var xxx_messageInfo_Projection proto.InternalMessageInfo

func (m *Projection) GetExprs() []*Expr {
	if m != nil {
		return m.Exprs
	}
	return nil
}

func (m *Projection) GetRpnExprs() []*RpnExpr {
	if m != nil {
		return m.RpnExprs
	}
	return nil
}

func (m *Projection) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

type Aggregation struct {
	// Group by clause.
	GroupBy    []*Expr    `protobuf:"bytes,1,rep,name=group_by,json=groupBy" json:"group_by,omitempty"`
	RpnGroupBy []*RpnExpr `protobuf:"bytes,4,rep,name=rpn_group_by,json=rpnGroupBy" json:"rpn_group_by,omitempty"`
	// Aggregate functions.
	AggFunc    []*Expr    `protobuf:"bytes,2,rep,name=agg_func,json=aggFunc" json:"agg_func,omitempty"`
	RpnAggFunc []*RpnExpr `protobuf:"bytes,5,rep,name=rpn_agg_func,json=rpnAggFunc" json:"rpn_agg_func,omitempty"`
	// If it is a stream aggregation.
	Streamed             bool      `protobuf:"varint,3,opt,name=streamed" json:"streamed"`
	Child                *Executor `protobuf:"bytes,6,opt,name=child" json:"child,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Aggregation) Reset()         { *m = Aggregation{} }
func (m *Aggregation) String() string { return proto.CompactTextString(m) }
func (*Aggregation) ProtoMessage()    {}
func (*Aggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{8}
}
func (m *Aggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Aggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Aggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Aggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Aggregation.Merge(m, src)
}
func (m *Aggregation) XXX_Size() int {
	return m.Size()
}
func (m *Aggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_Aggregation.DiscardUnknown(m)
}

var xxx_messageInfo_Aggregation proto.InternalMessageInfo

func (m *Aggregation) GetGroupBy() []*Expr {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *Aggregation) GetRpnGroupBy() []*RpnExpr {
	if m != nil {
		return m.RpnGroupBy
	}
	return nil
}

func (m *Aggregation) GetAggFunc() []*Expr {
	if m != nil {
		return m.AggFunc
	}
	return nil
}

func (m *Aggregation) GetRpnAggFunc() []*RpnExpr {
	if m != nil {
		return m.RpnAggFunc
	}
	return nil
}

func (m *Aggregation) GetStreamed() bool {
	if m != nil {
		return m.Streamed
	}
	return false
}

func (m *Aggregation) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

type TopN struct {
	// Order by clause.
	OrderBy              []*ByItem `protobuf:"bytes,1,rep,name=order_by,json=orderBy" json:"order_by,omitempty"`
	Limit                uint64    `protobuf:"varint,2,opt,name=limit" json:"limit"`
	Child                *Executor `protobuf:"bytes,3,opt,name=child" json:"child,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TopN) Reset()         { *m = TopN{} }
func (m *TopN) String() string { return proto.CompactTextString(m) }
func (*TopN) ProtoMessage()    {}
func (*TopN) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{9}
}
func (m *TopN) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopN) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopN.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopN) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopN.Merge(m, src)
}
func (m *TopN) XXX_Size() int {
	return m.Size()
}
func (m *TopN) XXX_DiscardUnknown() {
	xxx_messageInfo_TopN.DiscardUnknown(m)
}

var xxx_messageInfo_TopN proto.InternalMessageInfo

func (m *TopN) GetOrderBy() []*ByItem {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *TopN) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *TopN) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

type Limit struct {
	// Limit the result to be returned.
	Limit                uint64    `protobuf:"varint,1,opt,name=limit" json:"limit"`
	Child                *Executor `protobuf:"bytes,2,opt,name=child" json:"child,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Limit) Reset()         { *m = Limit{} }
func (m *Limit) String() string { return proto.CompactTextString(m) }
func (*Limit) ProtoMessage()    {}
func (*Limit) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{10}
}
func (m *Limit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Limit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Limit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Limit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Limit.Merge(m, src)
}
func (m *Limit) XXX_Size() int {
	return m.Size()
}
func (m *Limit) XXX_DiscardUnknown() {
	xxx_messageInfo_Limit.DiscardUnknown(m)
}

var xxx_messageInfo_Limit proto.InternalMessageInfo

func (m *Limit) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *Limit) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

type Kill struct {
	ConnID uint64 `protobuf:"varint,1,opt,name=connID" json:"connID"`
	// Query indicates whether terminate a single query on this connection or the whole connection.
	//   If Query is true, terminates the statement the connection is currently executing, but leaves the connection itself intact.
	//   If Query is false, terminates the connection associated with the given ConnectionID, after terminating any statement the connection is executing.
	//   See https://dev.mysql.com/doc/refman/8.0/en/kill.html.
	Query                bool     `protobuf:"varint,2,opt,name=query" json:"query"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Kill) Reset()         { *m = Kill{} }
func (m *Kill) String() string { return proto.CompactTextString(m) }
func (*Kill) ProtoMessage()    {}
func (*Kill) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{11}
}
func (m *Kill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Kill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Kill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Kill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Kill.Merge(m, src)
}
func (m *Kill) XXX_Size() int {
	return m.Size()
}
func (m *Kill) XXX_DiscardUnknown() {
	xxx_messageInfo_Kill.DiscardUnknown(m)
}

var xxx_messageInfo_Kill proto.InternalMessageInfo

func (m *Kill) GetConnID() uint64 {
	if m != nil {
		return m.ConnID
	}
	return 0
}

func (m *Kill) GetQuery() bool {
	if m != nil {
		return m.Query
	}
	return false
}

type ExecutorExecutionSummary struct {
	// Total time cost in this executor. Includes self time cost and children time cost.
	TimeProcessedNs *uint64 `protobuf:"varint,1,opt,name=time_processed_ns,json=timeProcessedNs" json:"time_processed_ns,omitempty"`
	// How many rows this executor produced totally.
	NumProducedRows *uint64 `protobuf:"varint,2,opt,name=num_produced_rows,json=numProducedRows" json:"num_produced_rows,omitempty"`
	// How many times executor's `next()` is called.
	NumIterations *uint64 `protobuf:"varint,3,opt,name=num_iterations,json=numIterations" json:"num_iterations,omitempty"`
	// Coresponding executor id
	ExecutorId *string `protobuf:"bytes,4,opt,name=executor_id,json=executorId" json:"executor_id,omitempty"`
	// The execution concurrency for this executor
	Concurrency          *uint64  `protobuf:"varint,5,opt,name=concurrency" json:"concurrency,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecutorExecutionSummary) Reset()         { *m = ExecutorExecutionSummary{} }
func (m *ExecutorExecutionSummary) String() string { return proto.CompactTextString(m) }
func (*ExecutorExecutionSummary) ProtoMessage()    {}
func (*ExecutorExecutionSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{12}
}
func (m *ExecutorExecutionSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutorExecutionSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutorExecutionSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutorExecutionSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutorExecutionSummary.Merge(m, src)
}
func (m *ExecutorExecutionSummary) XXX_Size() int {
	return m.Size()
}
func (m *ExecutorExecutionSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutorExecutionSummary.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutorExecutionSummary proto.InternalMessageInfo

func (m *ExecutorExecutionSummary) GetTimeProcessedNs() uint64 {
	if m != nil && m.TimeProcessedNs != nil {
		return *m.TimeProcessedNs
	}
	return 0
}

func (m *ExecutorExecutionSummary) GetNumProducedRows() uint64 {
	if m != nil && m.NumProducedRows != nil {
		return *m.NumProducedRows
	}
	return 0
}

func (m *ExecutorExecutionSummary) GetNumIterations() uint64 {
	if m != nil && m.NumIterations != nil {
		return *m.NumIterations
	}
	return 0
}

func (m *ExecutorExecutionSummary) GetExecutorId() string {
	if m != nil && m.ExecutorId != nil {
		return *m.ExecutorId
	}
	return ""
}

func (m *ExecutorExecutionSummary) GetConcurrency() uint64 {
	if m != nil && m.Concurrency != nil {
		return *m.Concurrency
	}
	return 0
}

func init() {
	proto.RegisterEnum("tipb.ExecType", ExecType_name, ExecType_value)
	proto.RegisterEnum("tipb.ExchangeType", ExchangeType_name, ExchangeType_value)
	proto.RegisterEnum("tipb.EngineType", EngineType_name, EngineType_value)
	proto.RegisterEnum("tipb.JoinType", JoinType_name, JoinType_value)
	proto.RegisterEnum("tipb.JoinExecType", JoinExecType_name, JoinExecType_value)
	proto.RegisterType((*Executor)(nil), "tipb.Executor")
	proto.RegisterType((*ExchangeSender)(nil), "tipb.ExchangeSender")
	proto.RegisterType((*ExchangeReceiver)(nil), "tipb.ExchangeReceiver")
	proto.RegisterType((*TableScan)(nil), "tipb.TableScan")
	proto.RegisterType((*Join)(nil), "tipb.Join")
	proto.RegisterType((*IndexScan)(nil), "tipb.IndexScan")
	proto.RegisterType((*Selection)(nil), "tipb.Selection")
	proto.RegisterType((*Projection)(nil), "tipb.Projection")
	proto.RegisterType((*Aggregation)(nil), "tipb.Aggregation")
	proto.RegisterType((*TopN)(nil), "tipb.TopN")
	proto.RegisterType((*Limit)(nil), "tipb.Limit")
	proto.RegisterType((*Kill)(nil), "tipb.Kill")
	proto.RegisterType((*ExecutorExecutionSummary)(nil), "tipb.ExecutorExecutionSummary")
}

func init() { proto.RegisterFile("executor.proto", fileDescriptor_12d1cdcda51e000f) }

var fileDescriptor_12d1cdcda51e000f = []byte{
	// 1615 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x57, 0x4f, 0x73, 0xe3, 0x48,
	0x15, 0x8f, 0x6c, 0xd9, 0x96, 0x9f, 0x1d, 0x5b, 0x69, 0x32, 0x41, 0x33, 0x40, 0xe2, 0x75, 0x6d,
	0x8a, 0xe0, 0x5a, 0xb2, 0xd9, 0x59, 0x28, 0xe0, 0x00, 0xb5, 0x93, 0x21, 0x61, 0x4c, 0x86, 0x90,
	0x52, 0x52, 0x5c, 0x55, 0xb2, 0xd4, 0x96, 0x3b, 0x91, 0xba, 0x95, 0x96, 0xc4, 0xd8, 0x37, 0x2e,
	0x7c, 0x02, 0x38, 0x70, 0xe3, 0x1b, 0xf0, 0x31, 0xa8, 0xa9, 0xe2, 0xc2, 0x95, 0x2a, 0x8a, 0xa2,
	0x86, 0x1b, 0x5f, 0x02, 0xaa, 0xbb, 0x25, 0x59, 0x8e, 0x9d, 0xec, 0x9c, 0xac, 0xfe, 0xbd, 0xdf,
	0x7b, 0xfd, 0xfa, 0xfd, 0xe9, 0x7e, 0x86, 0x1e, 0x9e, 0x63, 0x2f, 0x4b, 0x19, 0x3f, 0x8e, 0x39,
	0x4b, 0x19, 0xd2, 0x53, 0x12, 0x4f, 0x5e, 0x98, 0x78, 0x1e, 0x73, 0x9c, 0x24, 0x84, 0x51, 0x85,
	0xbf, 0xe8, 0x26, 0xde, 0x0c, 0x47, 0x6e, 0xbe, 0xda, 0x0d, 0x58, 0xc0, 0xe4, 0xe7, 0xe7, 0xe2,
	0x4b, 0xa1, 0xc3, 0xbf, 0xea, 0x60, 0x9c, 0xe5, 0xe6, 0xd0, 0xa7, 0x50, 0x4b, 0x63, 0x4b, 0x1b,
	0x68, 0x47, 0xbd, 0x97, 0xbd, 0x63, 0x61, 0xf5, 0x58, 0xc8, 0x6e, 0x16, 0x31, 0x3e, 0xd5, 0xdf,
	0xff, 0xeb, 0x60, 0xcb, 0xae, 0xa5, 0x31, 0x1a, 0x81, 0x91, 0x4e, 0x42, 0x27, 0xf1, 0x5c, 0x6a,
	0xd5, 0x06, 0xda, 0x51, 0xe7, 0x65, 0x5f, 0x71, 0x6f, 0xdc, 0x49, 0x88, 0xaf, 0x3d, 0x97, 0xda,
	0xad, 0x74, 0x12, 0x8a, 0x0f, 0xc1, 0x25, 0xfe, 0x5c, 0x71, 0xeb, 0x55, 0xee, 0x98, 0xfa, 0x78,
	0xae, 0xb8, 0xc4, 0x97, 0x1f, 0xe8, 0xfb, 0xd0, 0x4e, 0x70, 0x88, 0xbd, 0x94, 0x30, 0x6a, 0xe9,
	0x55, 0xf2, 0x75, 0x01, 0xdb, 0x4b, 0x06, 0xfa, 0x12, 0x3a, 0x6e, 0x10, 0x70, 0x1c, 0xb8, 0x52,
	0xa1, 0x21, 0x15, 0x76, 0x94, 0xc2, 0xab, 0xa5, 0xc0, 0xae, 0xb2, 0xd0, 0x3e, 0xe8, 0x29, 0x8b,
	0x2f, 0xad, 0xa6, 0x64, 0x43, 0xee, 0x37, 0x8b, 0x2f, 0x6d, 0x89, 0xa3, 0x4f, 0xa0, 0x11, 0x92,
	0x88, 0xa4, 0x56, 0x4b, 0x12, 0x3a, 0x8a, 0xf0, 0x56, 0x40, 0xb6, 0x92, 0xa0, 0xd7, 0xb0, 0x83,
	0xe7, 0xde, 0xcc, 0xa5, 0x01, 0x76, 0x38, 0xf6, 0x30, 0xf9, 0x2d, 0xe6, 0x96, 0x21, 0xe9, 0x7b,
	0x45, 0xcc, 0x94, 0xd8, 0xce, 0xa5, 0xb6, 0x89, 0x1f, 0x20, 0xc2, 0x8f, 0x5b, 0x46, 0xa8, 0xd5,
	0xae, 0xfa, 0xf1, 0x4b, 0x46, 0xa8, 0x2d, 0x71, 0x74, 0x00, 0x9d, 0x22, 0xc9, 0x0e, 0xf1, 0x2d,
	0x18, 0x68, 0x47, 0x6d, 0x1b, 0x0a, 0x68, 0xec, 0x0b, 0x03, 0x77, 0x24, 0x0c, 0xad, 0x4e, 0xd5,
	0xc0, 0x05, 0x09, 0x43, 0x5b, 0xe2, 0xe8, 0xa7, 0xd0, 0x2f, 0xbd, 0x4c, 0x30, 0xf5, 0x31, 0xb7,
	0xba, 0x92, 0xba, 0xbb, 0xea, 0xe3, 0xb5, 0x94, 0xd9, 0x3d, 0xbc, 0xb2, 0x46, 0x27, 0x00, 0x57,
	0x9c, 0xdd, 0xe6, 0xc9, 0xd8, 0x96, 0x9a, 0xa6, 0xd2, 0x5c, 0xe2, 0x76, 0x85, 0x33, 0xfc, 0x73,
	0x0d, 0x7a, 0xab, 0x46, 0xd1, 0x51, 0xa5, 0x9c, 0xd0, 0xea, 0xb6, 0x6b, 0x25, 0xb5, 0x83, 0xa9,
	0xc7, 0x7c, 0xec, 0x3b, 0xa9, 0x9b, 0xdc, 0x39, 0x11, 0x4e, 0x5d, 0xab, 0x36, 0xa8, 0x1f, 0x75,
	0xed, 0x7e, 0x2e, 0xb8, 0x71, 0x93, 0xbb, 0x5f, 0xe1, 0xd4, 0x45, 0x5f, 0x40, 0x2f, 0x76, 0x79,
	0x4a, 0xc4, 0xae, 0xce, 0x1d, 0x5e, 0x24, 0x56, 0x7d, 0x50, 0x5f, 0xc6, 0xe0, 0x6c, 0x1e, 0x73,
	0x7b, 0xbb, 0x64, 0x5c, 0xe0, 0x45, 0x82, 0x3e, 0x85, 0x86, 0x37, 0x23, 0xa1, 0x9f, 0x57, 0x55,
	0xa5, 0xb4, 0x45, 0x34, 0x6d, 0x25, 0x44, 0x87, 0xd0, 0x48, 0x17, 0x31, 0x4e, 0xac, 0x86, 0xb4,
	0x97, 0xd7, 0xde, 0x39, 0xc1, 0xa1, 0x2f, 0xdc, 0xb5, 0x95, 0x14, 0xfd, 0x08, 0xfa, 0x6e, 0x18,
	0x3a, 0x53, 0x81, 0x3b, 0x4a, 0xa1, 0xb9, 0x59, 0x61, 0xdb, 0x0d, 0xc3, 0x72, 0x95, 0x0c, 0xff,
	0xa8, 0x81, 0xf9, 0xb0, 0x34, 0x36, 0x9f, 0x5c, 0xdb, 0x7c, 0xf2, 0x13, 0xe8, 0x54, 0x77, 0xad,
	0x6d, 0xde, 0x15, 0xa6, 0xe5, 0x96, 0x68, 0x28, 0x33, 0x50, 0x7f, 0x2c, 0x03, 0x22, 0xf6, 0xc3,
	0xbf, 0xd5, 0xa0, 0x5d, 0x76, 0x2e, 0x3a, 0x00, 0x23, 0x15, 0x0b, 0x51, 0x75, 0x22, 0x73, 0xf5,
	0x3c, 0x4b, 0x2d, 0x89, 0x8e, 0x7d, 0x34, 0x82, 0x96, 0xc7, 0xc2, 0x2c, 0xa2, 0x85, 0x03, 0x79,
	0x59, 0xbc, 0x96, 0xe0, 0x98, 0x4e, 0x99, 0x5d, 0x10, 0x90, 0x05, 0xba, 0x8f, 0x13, 0x4f, 0x3a,
	0x60, 0xe4, 0x86, 0x24, 0x82, 0x3e, 0x03, 0x14, 0x73, 0x12, 0xb9, 0x7c, 0xe1, 0x28, 0xb2, 0x43,
	0xfc, 0xc4, 0xd2, 0x07, 0xf5, 0xa3, 0xba, 0x6d, 0xe6, 0x92, 0xdc, 0xa2, 0x9f, 0xa0, 0xaf, 0xc0,
	0xa4, 0x78, 0x9e, 0x3a, 0x1c, 0xbb, 0xbe, 0x83, 0x69, 0x40, 0x28, 0x96, 0xfd, 0xde, 0x2b, 0x36,
	0x3f, 0x93, 0x58, 0xa5, 0xa8, 0x7a, 0x82, 0x6f, 0x63, 0xd7, 0x57, 0x12, 0xf4, 0x19, 0x34, 0xb9,
	0x38, 0x75, 0x91, 0xab, 0xbc, 0x04, 0x2e, 0xf0, 0xc2, 0x16, 0x70, 0xae, 0x95, 0x73, 0xd0, 0x4f,
	0xe0, 0x79, 0xe1, 0x5d, 0xcc, 0xf1, 0x94, 0xcc, 0xab, 0x4e, 0xb6, 0xa4, 0x93, 0x7b, 0x39, 0xe1,
	0x4a, 0xca, 0x4b, 0x57, 0x87, 0xff, 0xd3, 0x41, 0x17, 0x7d, 0x8c, 0xbe, 0x80, 0xb6, 0xe8, 0x64,
	0x99, 0xab, 0xd5, 0x2b, 0x55, 0x88, 0x2b, 0xae, 0x1a, 0xb7, 0xf9, 0x1a, 0xfd, 0x0c, 0x7a, 0x52,
	0x45, 0xb4, 0xb9, 0xd2, 0xab, 0x55, 0x33, 0x27, 0xf4, 0x1e, 0x5c, 0xc7, 0xdd, 0xdb, 0x0a, 0x26,
	0x2e, 0x5b, 0x59, 0xc9, 0x1c, 0xd3, 0xbc, 0x27, 0x1e, 0x56, 0x7a, 0x29, 0x47, 0x9f, 0x40, 0x9b,
	0x50, 0x8a, 0xc5, 0xed, 0x32, 0x97, 0x6d, 0x51, 0x24, 0xda, 0x90, 0xf0, 0xd8, 0x9f, 0xa3, 0x13,
	0xe8, 0x85, 0x78, 0x9a, 0x3a, 0xd2, 0x27, 0xd9, 0x68, 0x8d, 0xb5, 0x46, 0xeb, 0x0a, 0x86, 0x70,
	0x4c, 0xf6, 0xd9, 0x4b, 0xe8, 0x73, 0x12, 0xcc, 0xaa, 0x2a, 0xcd, 0xf5, 0xde, 0x94, 0x94, 0x52,
	0xe7, 0x04, 0x3a, 0x31, 0x67, 0x13, 0x9c, 0x17, 0x75, 0xeb, 0x91, 0xa2, 0x96, 0x1c, 0x55, 0xd4,
	0x27, 0xd0, 0x99, 0x64, 0xa4, 0x6c, 0x03, 0xe3, 0x11, 0x0d, 0xc9, 0x51, 0x1a, 0x5f, 0x42, 0x5f,
	0x9e, 0xc4, 0x63, 0xd4, 0x97, 0xb7, 0x42, 0x62, 0xb5, 0xd7, 0xfc, 0x92, 0x87, 0x7d, 0x5d, 0x32,
	0xd0, 0x0f, 0xc1, 0x54, 0x87, 0xa9, 0x68, 0xc1, 0x9a, 0x96, 0x3a, 0xf0, 0xaa, 0x1a, 0x4b, 0x67,
	0x98, 0x57, 0xd5, 0x3a, 0xeb, 0x6a, 0x92, 0x53, 0x51, 0x7b, 0x03, 0xdf, 0x52, 0x6a, 0xf8, 0xbe,
	0xa2, 0xe9, 0x4c, 0x39, 0x8b, 0x1c, 0x42, 0xad, 0xee, 0x9a, 0x85, 0x6f, 0x4a, 0xfa, 0xd9, 0xfd,
	0xd2, 0xc6, 0x39, 0x67, 0xd1, 0x98, 0x0e, 0xff, 0xa1, 0x41, 0xbb, 0x7c, 0x5d, 0xbf, 0xbe, 0x9f,
	0x0f, 0xc0, 0x20, 0x82, 0x2d, 0x08, 0xb5, 0x2a, 0x41, 0xa2, 0xab, 0x0d, 0x5f, 0xff, 0xd8, 0x86,
	0xd7, 0xd7, 0x1a, 0x7e, 0x0f, 0x9a, 0x19, 0x25, 0xf7, 0x99, 0x6a, 0x5c, 0xc3, 0xce, 0x57, 0x8f,
	0x5c, 0x04, 0xcd, 0xcd, 0x17, 0xc1, 0xf0, 0x0f, 0x1a, 0xb4, 0xcb, 0x61, 0x00, 0x8d, 0x00, 0x2a,
	0x41, 0xd6, 0xd6, 0x42, 0x54, 0x91, 0xa2, 0x1f, 0x40, 0x8f, 0xc7, 0xb4, 0x9a, 0x14, 0x75, 0x7b,
	0x6d, 0x2b, 0xbe, 0x1d, 0xd3, 0xbc, 0x38, 0x63, 0x5a, 0xc9, 0x4a, 0xf9, 0x70, 0xd4, 0x9f, 0x78,
	0x38, 0x86, 0xbf, 0xd3, 0xaa, 0xaf, 0x25, 0x1a, 0x40, 0x43, 0x8c, 0x62, 0x9b, 0x3c, 0x52, 0x02,
	0x34, 0x82, 0xb6, 0x70, 0x46, 0xb1, 0x36, 0xfa, 0x61, 0x70, 0xf5, 0xf1, 0xb1, 0x2e, 0xfc, 0xbe,
	0x06, 0x9d, 0xca, 0xd0, 0x83, 0x0e, 0xc1, 0x08, 0x38, 0xcb, 0x62, 0x67, 0xb2, 0xd8, 0xe0, 0x46,
	0x4b, 0xca, 0x4e, 0x17, 0xe8, 0x73, 0xe8, 0x0a, 0x47, 0x4a, 0xaa, 0xbe, 0xc9, 0x17, 0xe0, 0x31,
	0xfd, 0x45, 0xae, 0x70, 0x08, 0x86, 0x1b, 0x04, 0xce, 0x34, 0xa3, 0x5e, 0xee, 0xf8, 0x8a, 0x5d,
	0x37, 0x08, 0xce, 0x33, 0xea, 0x15, 0x76, 0x4b, 0x6a, 0xe3, 0x31, 0xbb, 0xaf, 0x72, 0x85, 0x01,
	0x18, 0x49, 0xca, 0xb1, 0x1b, 0x61, 0x7f, 0xe5, 0xb5, 0x28, 0xd1, 0x65, 0x1c, 0x9a, 0x4f, 0xc5,
	0xe1, 0x1e, 0x74, 0x31, 0xcd, 0xa1, 0xef, 0x82, 0xc1, 0xb8, 0x8f, 0xf9, 0xf2, 0xfc, 0x5d, 0xa5,
	0x70, 0xba, 0x18, 0xa7, 0x38, 0xb2, 0x5b, 0x52, 0x7a, 0xba, 0x40, 0x2f, 0x8a, 0x81, 0x4f, 0xd4,
	0xbe, 0x9e, 0xef, 0x9a, 0x4f, 0x7a, 0x1f, 0x17, 0xfa, 0x31, 0x34, 0xe4, 0x7c, 0xb8, 0x34, 0xa5,
	0x3d, 0x61, 0xaa, 0xf6, 0x94, 0xa9, 0xaf, 0x40, 0x17, 0x23, 0x1c, 0xfa, 0x36, 0x34, 0x3d, 0x46,
	0xe9, 0xf8, 0xe7, 0x2b, 0xa6, 0x72, 0x4c, 0xec, 0x73, 0x9f, 0x61, 0xbe, 0x90, 0xb6, 0x8a, 0x40,
	0x29, 0x68, 0xf8, 0x4f, 0x0d, 0xac, 0xc2, 0xaa, 0xfa, 0x25, 0x8c, 0x5e, 0x67, 0x91, 0x68, 0x23,
	0x31, 0x6b, 0xa4, 0x24, 0xc2, 0x4e, 0xcc, 0x99, 0x87, 0x93, 0x04, 0xfb, 0x8e, 0x6c, 0x1b, 0xed,
	0x48, 0xb7, 0xfb, 0x42, 0x70, 0x55, 0xe0, 0x97, 0xa2, 0x44, 0x77, 0x68, 0x16, 0x09, 0xaa, 0x9f,
	0x79, 0xd8, 0x77, 0x38, 0x7b, 0x97, 0xa8, 0x18, 0xd9, 0x7d, 0x9a, 0x45, 0x57, 0x39, 0x6e, 0xb3,
	0x77, 0x09, 0x3a, 0x84, 0x9e, 0xe0, 0x92, 0x14, 0x73, 0x57, 0xf5, 0x56, 0x5d, 0x12, 0xb7, 0x69,
	0x16, 0x8d, 0x4b, 0xf0, 0xe1, 0x4c, 0xab, 0xaf, 0xcd, 0xb4, 0x03, 0xe8, 0x78, 0x8c, 0x7a, 0x19,
	0xe7, 0x98, 0x7a, 0x0b, 0x79, 0x51, 0xe8, 0x76, 0x15, 0x1a, 0xfd, 0x57, 0x53, 0xff, 0x56, 0xe4,
	0x73, 0xb7, 0x03, 0xdb, 0xe2, 0xb7, 0x9c, 0x5d, 0xcc, 0xad, 0x02, 0x2a, 0xaf, 0x3f, 0x53, 0x2b,
	0xa0, 0xf2, 0xd6, 0x30, 0x6b, 0xe8, 0x1b, 0xd0, 0x17, 0x50, 0xa5, 0x5f, 0xcc, 0x3a, 0xea, 0x82,
	0x21, 0xad, 0xb1, 0xf8, 0xd2, 0xd4, 0xd1, 0x36, 0xb4, 0xc5, 0x4a, 0x26, 0xd6, 0x6c, 0x94, 0x46,
	0x64, 0x31, 0xbe, 0x0a, 0x02, 0xb3, 0x59, 0xf0, 0xc5, 0x3b, 0x66, 0xb6, 0x8a, 0x95, 0xc8, 0x9e,
	0x69, 0xa0, 0x3d, 0x40, 0x62, 0xb5, 0x3a, 0x0e, 0x9b, 0x6d, 0x64, 0xc1, 0x6e, 0x15, 0x2f, 0x86,
	0x40, 0x13, 0x10, 0x82, 0x9e, 0x90, 0x2c, 0x6f, 0x11, 0xb3, 0x33, 0xfa, 0x31, 0x74, 0xab, 0xc3,
	0x1a, 0xea, 0x43, 0xe7, 0xca, 0x4d, 0x92, 0x9b, 0x19, 0x67, 0x59, 0x30, 0x33, 0xb7, 0x84, 0x93,
	0xa7, 0x9c, 0xb9, 0xbe, 0xe7, 0x26, 0xa9, 0xa9, 0x21, 0x03, 0xf4, 0x37, 0x6e, 0x32, 0x33, 0x6b,
	0xa3, 0x63, 0x80, 0xe5, 0x44, 0x84, 0xda, 0xd0, 0x78, 0xcb, 0x3c, 0x37, 0x34, 0xb7, 0x04, 0xe5,
	0x86, 0x5c, 0xfc, 0xc6, 0xd4, 0x50, 0x07, 0x5a, 0x37, 0xe4, 0x3c, 0x54, 0xfc, 0xbf, 0x68, 0x60,
	0x14, 0x53, 0xc9, 0x32, 0x86, 0x14, 0x73, 0x79, 0xba, 0x2d, 0xf4, 0x0c, 0x76, 0x64, 0x34, 0xf0,
	0x34, 0xfd, 0x75, 0x96, 0xe6, 0xb0, 0x56, 0x1c, 0xd3, 0x16, 0x2f, 0xe0, 0x12, 0xaf, 0x21, 0x13,
	0xba, 0x2a, 0xe4, 0x11, 0x91, 0x48, 0x1d, 0xed, 0x82, 0x29, 0x23, 0x4e, 0x53, 0x52, 0xa2, 0x3a,
	0x7a, 0x0e, 0xcf, 0x56, 0xcc, 0x96, 0xa2, 0x06, 0xfa, 0x0e, 0x3c, 0x2f, 0x14, 0xd6, 0xc5, 0xcd,
	0xd1, 0x00, 0xba, 0xd5, 0x69, 0xa8, 0xd8, 0x51, 0x1c, 0x5f, 0xb9, 0x7c, 0xfa, 0xbd, 0xf7, 0x1f,
	0xf6, 0xb5, 0xbf, 0x7f, 0xd8, 0xd7, 0xfe, 0xfd, 0x61, 0x5f, 0xfb, 0xd3, 0x7f, 0xf6, 0xb7, 0xe0,
	0x99, 0xc7, 0xa2, 0xe3, 0x98, 0xd0, 0xc0, 0x73, 0xe3, 0xe3, 0x94, 0xf8, 0x13, 0xd9, 0x83, 0x57,
	0xda, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0xeb, 0x47, 0x52, 0x3d, 0x4f, 0x0f, 0x00, 0x00,
}

func (m *Executor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Executor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Executor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Projection != nil {
		{
			size, err := m.Projection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.ExchangeSender != nil {
		{
			size, err := m.ExchangeSender.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Kill != nil {
		{
			size, err := m.Kill.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.ExecutorId != nil {
		i -= len(*m.ExecutorId)
		copy(dAtA[i:], *m.ExecutorId)
		i = encodeVarintExecutor(dAtA, i, uint64(len(*m.ExecutorId)))
		i--
		dAtA[i] = 0x52
	}
	if m.Join != nil {
		{
			size, err := m.Join.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ExchangeReceiver != nil {
		{
			size, err := m.ExchangeReceiver.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Limit != nil {
		{
			size, err := m.Limit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.TopN != nil {
		{
			size, err := m.TopN.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Aggregation != nil {
		{
			size, err := m.Aggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Selection != nil {
		{
			size, err := m.Selection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IdxScan != nil {
		{
			size, err := m.IdxScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TblScan != nil {
		{
			size, err := m.TblScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.Tp))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ExchangeSender) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeSender) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExchangeSender) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AllFieldTypes) > 0 {
		for iNdEx := len(m.AllFieldTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AllFieldTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.PartitionKeys) > 0 {
		for iNdEx := len(m.PartitionKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.EncodedTaskMeta) > 0 {
		for iNdEx := len(m.EncodedTaskMeta) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncodedTaskMeta[iNdEx])
			copy(dAtA[i:], m.EncodedTaskMeta[iNdEx])
			i = encodeVarintExecutor(dAtA, i, uint64(len(m.EncodedTaskMeta[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.Tp))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ExchangeReceiver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeReceiver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExchangeReceiver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Tp != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.Tp))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FieldTypes) > 0 {
		for iNdEx := len(m.FieldTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FieldTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.EncodedTaskMeta) > 0 {
		for iNdEx := len(m.EncodedTaskMeta) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncodedTaskMeta[iNdEx])
			copy(dAtA[i:], m.EncodedTaskMeta[iNdEx])
			i = encodeVarintExecutor(dAtA, i, uint64(len(m.EncodedTaskMeta[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TableScan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PrimaryPrefixColumnIds) > 0 {
		for iNdEx := len(m.PrimaryPrefixColumnIds) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintExecutor(dAtA, i, uint64(m.PrimaryPrefixColumnIds[iNdEx]))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.Ranges) > 0 {
		for iNdEx := len(m.Ranges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ranges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.NextReadEngine))
	i--
	dAtA[i] = 0x28
	if len(m.PrimaryColumnIds) > 0 {
		for iNdEx := len(m.PrimaryColumnIds) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintExecutor(dAtA, i, uint64(m.PrimaryColumnIds[iNdEx]))
			i--
			dAtA[i] = 0x20
		}
	}
	i--
	if m.Desc {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.TableId))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Join) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Join) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Join) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OtherEqConditionsFromIn) > 0 {
		for iNdEx := len(m.OtherEqConditionsFromIn) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OtherEqConditionsFromIn[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.OtherConditions) > 0 {
		for iNdEx := len(m.OtherConditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OtherConditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.RightConditions) > 0 {
		for iNdEx := len(m.RightConditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightConditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.LeftConditions) > 0 {
		for iNdEx := len(m.LeftConditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftConditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.BuildTypes) > 0 {
		for iNdEx := len(m.BuildTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BuildTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ProbeTypes) > 0 {
		for iNdEx := len(m.ProbeTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProbeTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.RightJoinKeys) > 0 {
		for iNdEx := len(m.RightJoinKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightJoinKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LeftJoinKeys) > 0 {
		for iNdEx := len(m.LeftJoinKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftJoinKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.InnerIdx))
	i--
	dAtA[i] = 0x20
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.JoinExecType))
	i--
	dAtA[i] = 0x10
	i = encodeVarintExecutor(dAtA, i, uint64(m.JoinType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *IndexScan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PrimaryColumnIds) > 0 {
		for iNdEx := len(m.PrimaryColumnIds) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintExecutor(dAtA, i, uint64(m.PrimaryColumnIds[iNdEx]))
			i--
			dAtA[i] = 0x30
		}
	}
	if m.Unique != nil {
		i--
		if *m.Unique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	i--
	if m.Desc {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.IndexId))
	i--
	dAtA[i] = 0x10
	i = encodeVarintExecutor(dAtA, i, uint64(m.TableId))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Selection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Selection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Selection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RpnConditions) > 0 {
		for iNdEx := len(m.RpnConditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RpnConditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Projection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Projection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Projection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RpnExprs) > 0 {
		for iNdEx := len(m.RpnExprs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RpnExprs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Exprs) > 0 {
		for iNdEx := len(m.Exprs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Exprs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Aggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Aggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.RpnAggFunc) > 0 {
		for iNdEx := len(m.RpnAggFunc) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RpnAggFunc[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RpnGroupBy) > 0 {
		for iNdEx := len(m.RpnGroupBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RpnGroupBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i--
	if m.Streamed {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	if len(m.AggFunc) > 0 {
		for iNdEx := len(m.AggFunc) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AggFunc[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.GroupBy) > 0 {
		for iNdEx := len(m.GroupBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TopN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopN) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopN) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.Limit))
	i--
	dAtA[i] = 0x10
	if len(m.OrderBy) > 0 {
		for iNdEx := len(m.OrderBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Limit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Limit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Limit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.Limit))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Kill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Kill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Kill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	i--
	if m.Query {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i = encodeVarintExecutor(dAtA, i, uint64(m.ConnID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ExecutorExecutionSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutorExecutionSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutorExecutionSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Concurrency != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.Concurrency))
		i--
		dAtA[i] = 0x28
	}
	if m.ExecutorId != nil {
		i -= len(*m.ExecutorId)
		copy(dAtA[i:], *m.ExecutorId)
		i = encodeVarintExecutor(dAtA, i, uint64(len(*m.ExecutorId)))
		i--
		dAtA[i] = 0x22
	}
	if m.NumIterations != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.NumIterations))
		i--
		dAtA[i] = 0x18
	}
	if m.NumProducedRows != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.NumProducedRows))
		i--
		dAtA[i] = 0x10
	}
	if m.TimeProcessedNs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TimeProcessedNs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintExecutor(dAtA []byte, offset int, v uint64) int {
	offset -= sovExecutor(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Executor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.Tp))
	if m.TblScan != nil {
		l = m.TblScan.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.IdxScan != nil {
		l = m.IdxScan.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Selection != nil {
		l = m.Selection.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Aggregation != nil {
		l = m.Aggregation.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.TopN != nil {
		l = m.TopN.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Limit != nil {
		l = m.Limit.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.ExchangeReceiver != nil {
		l = m.ExchangeReceiver.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Join != nil {
		l = m.Join.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.ExecutorId != nil {
		l = len(*m.ExecutorId)
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Kill != nil {
		l = m.Kill.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.ExchangeSender != nil {
		l = m.ExchangeSender.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Projection != nil {
		l = m.Projection.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExchangeSender) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.Tp))
	if len(m.EncodedTaskMeta) > 0 {
		for _, b := range m.EncodedTaskMeta {
			l = len(b)
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.PartitionKeys) > 0 {
		for _, e := range m.PartitionKeys {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.AllFieldTypes) > 0 {
		for _, e := range m.AllFieldTypes {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExchangeReceiver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EncodedTaskMeta) > 0 {
		for _, b := range m.EncodedTaskMeta {
			l = len(b)
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.FieldTypes) > 0 {
		for _, e := range m.FieldTypes {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Tp != nil {
		n += 1 + sovExecutor(uint64(*m.Tp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableScan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.TableId))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 2
	if len(m.PrimaryColumnIds) > 0 {
		for _, e := range m.PrimaryColumnIds {
			n += 1 + sovExecutor(uint64(e))
		}
	}
	n += 1 + sovExecutor(uint64(m.NextReadEngine))
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.PrimaryPrefixColumnIds) > 0 {
		for _, e := range m.PrimaryPrefixColumnIds {
			n += 1 + sovExecutor(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Join) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.JoinType))
	n += 1 + sovExecutor(uint64(m.JoinExecType))
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 1 + sovExecutor(uint64(m.InnerIdx))
	if len(m.LeftJoinKeys) > 0 {
		for _, e := range m.LeftJoinKeys {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RightJoinKeys) > 0 {
		for _, e := range m.RightJoinKeys {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.ProbeTypes) > 0 {
		for _, e := range m.ProbeTypes {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.BuildTypes) > 0 {
		for _, e := range m.BuildTypes {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.LeftConditions) > 0 {
		for _, e := range m.LeftConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RightConditions) > 0 {
		for _, e := range m.RightConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.OtherConditions) > 0 {
		for _, e := range m.OtherConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.OtherEqConditionsFromIn) > 0 {
		for _, e := range m.OtherEqConditionsFromIn {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IndexScan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.TableId))
	n += 1 + sovExecutor(uint64(m.IndexId))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 2
	if m.Unique != nil {
		n += 2
	}
	if len(m.PrimaryColumnIds) > 0 {
		for _, e := range m.PrimaryColumnIds {
			n += 1 + sovExecutor(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Selection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RpnConditions) > 0 {
		for _, e := range m.RpnConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Projection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Exprs) > 0 {
		for _, e := range m.Exprs {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RpnExprs) > 0 {
		for _, e := range m.RpnExprs {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Aggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupBy) > 0 {
		for _, e := range m.GroupBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.AggFunc) > 0 {
		for _, e := range m.AggFunc {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 2
	if len(m.RpnGroupBy) > 0 {
		for _, e := range m.RpnGroupBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RpnAggFunc) > 0 {
		for _, e := range m.RpnAggFunc {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopN) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 1 + sovExecutor(uint64(m.Limit))
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Limit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.Limit))
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Kill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.ConnID))
	n += 2
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecutorExecutionSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimeProcessedNs != nil {
		n += 1 + sovExecutor(uint64(*m.TimeProcessedNs))
	}
	if m.NumProducedRows != nil {
		n += 1 + sovExecutor(uint64(*m.NumProducedRows))
	}
	if m.NumIterations != nil {
		n += 1 + sovExecutor(uint64(*m.NumIterations))
	}
	if m.ExecutorId != nil {
		l = len(*m.ExecutorId)
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Concurrency != nil {
		n += 1 + sovExecutor(uint64(*m.Concurrency))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovExecutor(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozExecutor(x uint64) (n int) {
	return sovExecutor(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Executor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Executor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Executor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= ExecType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TblScan == nil {
				m.TblScan = &TableScan{}
			}
			if err := m.TblScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdxScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdxScan == nil {
				m.IdxScan = &IndexScan{}
			}
			if err := m.IdxScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selection == nil {
				m.Selection = &Selection{}
			}
			if err := m.Selection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggregation == nil {
				m.Aggregation = &Aggregation{}
			}
			if err := m.Aggregation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopN", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopN == nil {
				m.TopN = &TopN{}
			}
			if err := m.TopN.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limit == nil {
				m.Limit = &Limit{}
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExchangeReceiver == nil {
				m.ExchangeReceiver = &ExchangeReceiver{}
			}
			if err := m.ExchangeReceiver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Join == nil {
				m.Join = &Join{}
			}
			if err := m.Join.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ExecutorId = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kill == nil {
				m.Kill = &Kill{}
			}
			if err := m.Kill.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeSender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExchangeSender == nil {
				m.ExchangeSender = &ExchangeSender{}
			}
			if err := m.ExchangeSender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Projection == nil {
				m.Projection = &Projection{}
			}
			if err := m.Projection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeSender) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeSender: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeSender: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= ExchangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedTaskMeta", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedTaskMeta = append(m.EncodedTaskMeta, make([]byte, postIndex-iNdEx))
			copy(m.EncodedTaskMeta[len(m.EncodedTaskMeta)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionKeys = append(m.PartitionKeys, &Expr{})
			if err := m.PartitionKeys[len(m.PartitionKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &FieldType{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllFieldTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllFieldTypes = append(m.AllFieldTypes, &FieldType{})
			if err := m.AllFieldTypes[len(m.AllFieldTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeReceiver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeReceiver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeReceiver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedTaskMeta", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedTaskMeta = append(m.EncodedTaskMeta, make([]byte, postIndex-iNdEx))
			copy(m.EncodedTaskMeta[len(m.EncodedTaskMeta)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldTypes = append(m.FieldTypes, &FieldType{})
			if err := m.FieldTypes[len(m.FieldTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			var v ExchangeType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ExchangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tp = &v
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExecutor
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PrimaryColumnIds) == 0 {
					m.PrimaryColumnIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColumnIds", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextReadEngine", wireType)
			}
			m.NextReadEngine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextReadEngine |= EngineType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, KeyRange{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryPrefixColumnIds = append(m.PrimaryPrefixColumnIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExecutor
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PrimaryPrefixColumnIds) == 0 {
					m.PrimaryPrefixColumnIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryPrefixColumnIds = append(m.PrimaryPrefixColumnIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryPrefixColumnIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Join) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Join: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Join: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinType", wireType)
			}
			m.JoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinType |= JoinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinExecType", wireType)
			}
			m.JoinExecType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinExecType |= JoinExecType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &Executor{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerIdx", wireType)
			}
			m.InnerIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InnerIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftJoinKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftJoinKeys = append(m.LeftJoinKeys, &Expr{})
			if err := m.LeftJoinKeys[len(m.LeftJoinKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightJoinKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightJoinKeys = append(m.RightJoinKeys, &Expr{})
			if err := m.RightJoinKeys[len(m.RightJoinKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbeTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProbeTypes = append(m.ProbeTypes, &FieldType{})
			if err := m.ProbeTypes[len(m.ProbeTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildTypes = append(m.BuildTypes, &FieldType{})
			if err := m.BuildTypes[len(m.BuildTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftConditions = append(m.LeftConditions, &Expr{})
			if err := m.LeftConditions[len(m.LeftConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightConditions = append(m.RightConditions, &Expr{})
			if err := m.RightConditions[len(m.RightConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherConditions = append(m.OtherConditions, &Expr{})
			if err := m.OtherConditions[len(m.OtherConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherEqConditionsFromIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherEqConditionsFromIn = append(m.OtherEqConditionsFromIn, &Expr{})
			if err := m.OtherEqConditionsFromIn[len(m.OtherEqConditionsFromIn)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Unique = &b
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExecutor
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PrimaryColumnIds) == 0 {
					m.PrimaryColumnIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColumnIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Selection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Selection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Selection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &Expr{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpnConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpnConditions = append(m.RpnConditions, &RpnExpr{})
			if err := m.RpnConditions[len(m.RpnConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Projection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Projection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Projection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exprs = append(m.Exprs, &Expr{})
			if err := m.Exprs[len(m.Exprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpnExprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpnExprs = append(m.RpnExprs, &RpnExpr{})
			if err := m.RpnExprs[len(m.RpnExprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, &Expr{})
			if err := m.GroupBy[len(m.GroupBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggFunc = append(m.AggFunc, &Expr{})
			if err := m.AggFunc[len(m.AggFunc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streamed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Streamed = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpnGroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpnGroupBy = append(m.RpnGroupBy, &RpnExpr{})
			if err := m.RpnGroupBy[len(m.RpnGroupBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpnAggFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpnAggFunc = append(m.RpnAggFunc, &RpnExpr{})
			if err := m.RpnAggFunc[len(m.RpnAggFunc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &ByItem{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Limit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Limit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Limit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Kill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Kill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Kill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnID", wireType)
			}
			m.ConnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Query = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutorExecutionSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutorExecutionSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutorExecutionSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeProcessedNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeProcessedNs = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumProducedRows", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumProducedRows = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumIterations", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumIterations = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ExecutorId = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concurrency", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Concurrency = &v
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExecutor(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthExecutor
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupExecutor
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthExecutor
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthExecutor        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExecutor          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupExecutor = fmt.Errorf("proto: unexpected end of group")
)
